## 1. 방문자 패턴?

- 방문자 패턴 (Visitor Pattern)

  > 객체의 구조(클래스 구조)와 그 구조에서 수행되는 작업(ex. 특정 메서드)을 분리하여 구현하는 패턴
  >

  우리 집에 아주 많은 장난감이 있다.

  이 장난감들 중에는 자동차도 있고, 로봇도 있고, 인형도 있다.

  근데, 어느 날 너희 집에 친구가 놀러 왔다. 이 친구는 장난감을 하나하나 보면서, 자동차는 어떻게 굴러가는지, 로봇은 어떻게 움직이는지, 인형은 어떻게 노는지 알고 싶어한다.

  방문자 패턴이 바로 이런 맥락으로 보면 쉽다.

  친구(방문자)가 집에 와서 각 장난감(객체)을 하나씩 보면서(방문하면서) 어떻게 사용하는지 알아내는 것.  이때, 장난감들은 그냥 자기가 무엇인지 그대로 있고, 친구가 그걸 알아내는 것.

    <aside>
    💡 쉽게 말해, 방문자 패턴은 **객체의 구조는 그대로 두고**, 그 **객체가 어떤 일을 할지를 외부에서 정의**할 수 있도록 해주는 방법이야. 이렇게 하면 새로운 기능을 추가할 때 객체를 수정하지 않고도 쉽게 추가할 수 있어.

    </aside>


## 2. 구조

- Element(요소) 인터페이스: 방문자가 방문할 객체들의 공통 인터페이스입니다. 이 인터페이스는 accept 메소드를 가지고 있어서, 방문자가 자신을 방문할 수 있도록 합니다.
- ConcreteElement(구체적인 요소) 클래스: Element 인터페이스를 구현한 클래스들입니다. 방문자가 방문할 실제 객체들입니다.
- Visitor(방문자) 인터페이스: Element 객체들을 방문하는 메소드들을 선언한 인터페이스입니다.
- ConcreteVisitor(구체적인 방문자) 클래스: Visitor 인터페이스를 구현한 클래스들입니다. Element 객체들을 방문하는 구체적인 방법들을 구현합니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/61a5c6bf-7a59-4970-897f-bce1b48b7ca4/bf7cf07d-fdc6-49a9-873c-97ff2b9b26f1/Untitled.png)

## **3. 사용 이유**

- 기능추가가 쉬워진다
    - 장난감이 여러개 있는데, 어떤 장난감은 소리를 내고 어떤 장난감은 움직인다. 그런데 새 친구가 놀러와서 이 장난감을 새로운 방식으로 가지고 놀고 싶어할 수 있다. 이때 장난감마다 새로운 기능을 추가하려면 모든 장난감을 다 고쳐야하는데 방문자 패턴을 사용하면 장난감을 어떻게 가지고 놀지에 대하여 외부에서 새롭게 정의하여 사용할 수 있다.
    - 객체의 구조와 기능 분리
        - 객체의 구조를 변경하지 않고도, 다양한 방식으로 장난감 사용방식을 추가할 수 있다.